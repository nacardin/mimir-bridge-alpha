use futures::{Future,Stream,Sink};
use futures::future::Executor;
use redis::{self,NonBlockHandle,BlockingHandle};
use websocket::stream::async::Stream as WsStream;
use websocket::client::async::Client;
use websocket::OwnedMessage;
use common::{
    Operation,
    Identity,
    CMD,
};
use edge::{
    OperationFilter,
    Error,
};
use std::net::SocketAddr;


// TODO: convert the various trait objects below into concrete types.
// especially the `Sender` and `Receiver` aliases.


pub type Sender = Box<Sink<SinkItem=Operation,SinkError=Error>>;

pub type Receiver = Box<Stream<Item=Operation,Error=Error>>;


fn build_conn_work(client_handles: (Sender,Receiver), redis_handles: (Sender,Receiver), ident: Identity) -> Box<Future<Item=(),Error=Error>> {
    let filter = OperationFilter::new(ident);
    let (client_tx,client_rx) = client_handles;
    let (redis_tx,redis_rx) = redis_handles;
    let incoming = client_rx.and_then(move |op| {
        filter.filter_incoming(op)
    }).forward(redis_tx).map(|_|());
    let outgoing = redis_rx.and_then(move |op| {
        filter.filter_outgoing(op)
    }).forward(client_tx).map(|_|());
    let work = incoming.select(outgoing)
        .map(|_|()).map_err(|(err,_)|err);
    Box::new(work)
}


pub fn init_redis<E>(address: &SocketAddr, executor: E, ident: Identity) -> Box<Future<Item=(Sender,Receiver),Error=Error>> 
        where E: Executor<Box<Future<Item=(),Error=()> + Send>> + Clone + 'static {
    let spawn_nonblock = redis::spawn_nonblock(address,executor.clone());
    let spawn_blocking = redis::spawn_blocking(address,executor); 
    let work = spawn_nonblock.join(spawn_blocking).map_err(|e|Error::from(e))
        .map(move |(nonblock,blocking)| configure_redis(nonblock,blocking,ident));
    Box::new(work)
}


fn configure_redis(nonblock: NonBlockHandle, blocking: BlockingHandle, ident: Identity) -> (Sender,Receiver) {
    let sender = redis::PushSink::new(nonblock).with(|op: Operation| {
        let channel: String = op.dest_channel().to_string();
        let payload: String = op.into();
        Ok((channel,payload))
    });
    let channels: Vec<_> = [ident.direct_channel(),ident.shared_channel()]
        .iter().map(|chnl| chnl.to_string()).collect();
    let receiver = redis::PopStream::new(blocking,channels).map_err(|e|Error::from(e))
        .and_then(|(_,msg): (String,String)| {
            Operation::from_string(msg).map_err(|e|Error::from(e))
        });
    (Box::new(sender),Box::new(receiver))
}


// TODO: handle non-text msg variants & proper ping/pong behavior
pub fn split_client<S>(client: Client<S>) -> (Sender,Receiver)
        where S: WsStream + 'static {
    let (tx,rx) = client.split();
    let sender = tx.with(|op: Operation| {
        let text: String = op.into();
        Ok(OwnedMessage::Text(text))
    });
    let receiver = rx.map_err(|e|Error::from(e))
        .and_then(|msg: OwnedMessage| {
            match msg {
                OwnedMessage::Text(text) => {
                    Operation::from_string(text)
                        .map_err(|e|Error::from(e))
                },
                _ => Err(Error::Other("handler for non-text variants not yet implemented"))
            }
        });
    (Box::new(sender),Box::new(receiver))
}


pub fn handshake<S>(client_stream: S) -> Box<Future<Item=(Identity,S),Error=Error>> 
        where S: Stream<Item=Operation,Error=Error> + 'static {
    let work = client_stream.into_future()
        .map_err(|(error,_)|error)
        .and_then(|(item,stream)| {
            if let Some(op) = item {
                process_handshake(op)
                    .map(move |ident|(ident,stream))
            } else {
                Err("stream terminated prior to handshake".into())
            }
        });
    Box::new(work)
}


fn process_handshake(op: Operation) -> Result<Identity,Error> {
    let cmd = op.expect_command(CMD::IDENTIFY)
        .map_err(|_|"handshake variant must be `CMD::IDENTIFY`")?;
    if let Some(address) = cmd.recover().map_err(|_|"unrecoverable signature")? {
        if cmd.dest.address == address {
            Ok(cmd.dest)
        } else {
            Err("signer address does not match claim".into())
        }
    } else {
        Err("missing signature in handshake".into())
    }
}

