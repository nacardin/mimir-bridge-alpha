//! utilities for working with message steps 
use message::{OSTEPS,VSTEPS,OCIRCUIT,VCIRCUIT};


/// flag representing the various certification steps of the
/// mimir bridge protocol.
///
#[derive(Debug,Copy,Clone,PartialEq,Eq)]
pub enum STEP {
    /// initial worker cert, generated by the validator that constructs
    /// the message payload.  same as a `verify` cert except that
    /// the producer must certify in the affirmative.
    ORACLE,

    /// generated by the mimir notary microservice, certifying that
    /// a message passed though the bridge.
    NOTARY,
 
    /// hash revealed by the requester at the beginning of a circuit
    /// as part of the trustless routing/randomization protocol.
    BLIND,

    /// seed of the blind; revealed at the completion of a circuit
    /// for trustless routing/randomization of the next circuit.
    CLEAR,

    /// route through the graph of active validators, generated by the
    /// router at the beginning of each verification circuit.
    ROUTE,

    /// verification cert added by each validator, confirming or refuting
    /// the validity of the message payload.
    VERIFY
}



impl STEP {
    /// generate a new `STEP` instance based on the numeric step index.
    pub fn new(index: usize) -> Self {
        if index < OSTEPS {
            OCIRCUIT[index]
        } else {
            let index = (index - OSTEPS) % VSTEPS;
            VCIRCUIT[index]
        }
    }
}

#[cfg(test)]
mod tests {
    use message::{OCIRCUIT,VCIRCUIT};
    use message::step::STEP;

    #[test]
    fn step_iterations() {
        let mut expect = Vec::new();
        expect.extend_from_slice(&OCIRCUIT);
        expect.extend_from_slice(&VCIRCUIT);
        expect.extend_from_slice(&VCIRCUIT);
        let actual: Vec<STEP> = (0..(expect.len())).into_iter()
            .map(|i| STEP::new(i)).collect();
        assert_eq!(expect,actual);
    }
}


